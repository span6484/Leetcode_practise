#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

简单

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

 

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

 

**提示：**

1. 各函数的调用总次数不超过 20000 次

 





---

##### 思路1	stack方法

两个stack， 一个用来正常存储 stack1， 另一个存储最小值 stack2， 当 cur value < stack2 中的第一个 （FIFO), push进两个stack， 否则只push进stack1. 

```
Ex: 5,4,-1,0,9,-2

Stack1: -2,9,0,-1,4,5

Stack2: -2,-1,4,5
```

当stack1待 pop 值 **等于** stack2 待 pop 值, 则 同时pop

```
-2
Stack1: 9,0,-1,4,5

Stack2: -1,4,5
```

如果不同， 则只pop stack1

```
9,0
Stack1: -1,4,5

Stack2: -1,4,5
```

###### **BUG**

1. **==** 

   ```java
   // stack1.getFirst() = 3,stack2.getFirst() = 3	
   if (stack1.getFirst() == stack2.getFirst())			//false
   ```

   **如果是2个Integer，==比较的对象是否相等，equals比较的是值是否相等。如果是2个Integer，需要看你比较的哪种场景。**

---

##### 思路2	链表存储方法	🌟

构建linkedlist， 每个list存储当前最小值， 每push一个就往左边添加一个Node， 删除就是`head = head.next` 往右边更新，